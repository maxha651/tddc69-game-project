1. Introduktion till projektet
"Space Explorer" är ett open singleplayer sci-fi rymdspel som inte direkt har något slutmål utan
 handlar snarare om att klara delmål. Idéen är att man har ett rymdskepp som man kan styra som man
  vill i en 2D-rymd. I 2D-rymden kan man stöta på olika slumpade händelser, t.ex. fiender, planeter
  eller asteroider. Delmålen är då endast att man hanterar situationerna som uppstår på det sättet man vill.

   Spelet kommer även att ha vissa rollspelsinslag, som t.ex. vapenupgraderingar, handel och erfarenhetsniåver.

2. Ytterligare bakgrundsinformation
I spelet finns ganska få regler. Dock kan spelare dö om dennes skepp förstörs.
Detta görs genom att samtliga delar av skeppet eller cockpit förstörs av fienden eller av
kollision med t.ex. asteroider. Skeppet kommer att vara uppdelat i följande delar:

Motor (för spelaren i någon riktning)
Vapen (används för att strida mot fienden)
Cockpit (spelaren dör om den går sönder)
Cargo (spelaren förlorar sina föremål)

Fienden kommer att vara uppdelade på liknande sätt.

Om något är sönder (förutom cockpit) kan det repareras. Dock behövs det material för detta.
Material kan fås från objekt (asteroider mm) i spelet. Genom att samla på sig material kan man uppgradera skeppet.
Man får poäng av att slå fiender, samla på sig material mm.

3. Milstolpar
Implementera ett styrbart rymdskeppsobjekt som visas grafiskt som en rektangel i en tom 2D-rymd.
Implementera fiendeobjekt som asteroider och andra skepp.
Implementera kollisionskontroll och enkelt vapensystem.
Implementera en enkel AI.
Implementera rymdskeppsdelar med cargo, motor och vapensystem.
Implementera föremål som går att plocka på sig ("loot").
Implementera en slumpad rymdvärld.
Implementera 2D-grafik.
Implementera animationer.
Implementera ett GUI (även GUI för cargo).
Implementera andra ickeobligatoriska saker som t.ex. handel, uppgraderingar, material, nya fiender eller rymdstationer.
Finputs av spel.

4. Övriga implementationsförberedelser
Vi kommer att använda MVC-modellen.

Vi kommer att ha en model som innehåller rymden som spelplan (klassen "Space"). Klassen "Space" kommer sedan att innehålla hashmaps med fiender, objekt, asteroider och diverse saker som kan finnas i en rymd. Hashfunktionen kommer att ta hänsyn till position i planet (varje "delrum" kommer att ha sitt egna positionssystem och egna hashmap). "Objekten i rymden" kommer alla att använda states bl. a. för att hålla koll på egenskaper och om man interagerat med objekt eller inte. Dessa objekt kommer att loopas igenom för förflyttning och kollisionscheck. Tack vare hashmaps kommer endast vissa objekt behöva loopas igenom för t.ex. AI och kollisionscheck.

Viewern kommer att bestå av en SpaceFrame som ärver av JFrame i Swing. Vi kommer sedan att ha en komponent ("SpaceComponent") som visar rymden och spelarens skepp.

Controllern (SpaceGame) kommer att innehålla en gameloop och en animations-/grafikloop som antagligen kommer att vara separata för att kunna hålla så hög och jämn framerate som möjligt. Gameloopen kommer att uppdatera modellen (Space) genom att låta modellen uppdatera sig själv. Grafikloopen kommer att m.h.a. modellen uppdatera grafiken i "SpaceComponent".

Abstraktion och objektorienterad design (MVC, Abstract Factory och States) kommer att användas såpass mycket det går.

5. Utveckling och samarbete
Vi har tänkt använda subversion och IDEA som utvecklingsmiljö. Vi kommer att sedan att arbeta tillsammans och separat med kontinuerlig kommunikation och samförståelse för alla delar av spelet via Skype (röstkommunkiation via internet). Vem som gör vad beror på vad vi håller på med i projektet och vem som då har mest tid. Vi har samma ambitioner.

Är vi oense om något spelar vi "sten, sax, påse" eller "tärning". Är vi oense om vad vi ska spela så spelar vi en match Half-Life 2: Deathmatch; den som vinner bestämmer sedan vad vi ska göra.

6. Implementationsbeskrivning
Den här delen skriver ni inför slutinlämningen
Det här kapitlet använder ni för att beskriva hur projektet är strukturerat och implementerat. Algoritmer och övergripande design passar också in i det här kapitlet (bilder, flödesdiagram, osv. kan vara användbart). Skapa gärna egna delkapitel för enskilda delar, om det underlättar.

6.1. Dokumentation för programkod
Programkod behöver dokumenteras för att man ska förstå hur den fungerar och hur allt hänger ihop.  Vissa typer av dokumentation är direkt relaterad till ett enda fält, en enda metod eller en enda klass och placeras då lämpligast vid fältet, metoden eller klassen i en Javadoc-kommentar.  Då är det både enklare att hitta dokumentationen och större chans att den faktiskt uppdateras när det sker ändringar.  Annan dokumentation är mer övergripande och placeras då här.  Det kan gälla till exempel:
Övergripande programstruktur, t.ex. att man har implementerat ett spel som styrs av timer-tick n gånger per sekund där man vid varje sådant tick först tar hand om input och gör eventuella förflyttningar för objekt av typ X, Y och Z, därefter kontrollerar kollisioner vilket sker med hjälp av klass W, och till slut uppdaterar skärmen.
Översikter över relaterade klasser och hur de hänger ihop.  Här kan det ofta vara bra att använda UML-diagram för att illustrera – men fundera då först på vilka grupper av klasser det är ni vill beskriva, och skapa sedan ett UML-diagram för varje grupp av klasser (det är sällan särskilt användbart att lägga in hela projektet i ett enda gigantiskt diagram).  Skriv sedan en textbeskrivning av vad det är ni illustrerar med UML-diagrammet.  Texten är den huvudsakliga dokumentationen medan UML-diagrammet hjälper läsaren att förstå texten och få en översikt.  IDEA kan hjälpa till att göra klassdiagram som ni sedan kan klippa och klistra in i dokumentet.
Labbhandledaren och examinatorn kommer bland annat att använda den här dokumentationen för att förstå programmet vid bedömningen.  Ni kan också tänka er att ni själva ska vidareutveckla projektet efter att en annan grupp har utvecklat grunden.  Vad skulle ni själva vilja veta i det läget?  Om viktig information saknas kan ni få komplettera.
Se även sidan om krav på programkod på webben.

6.2. Användning av fritt material
Vi har inte använt något fritt material.

6.3. Användning av designmönster
Model-View-Controller
 Vi använde MVC då det är ett bra sätt att hålla isär de progrmmets olika delar. Detta gjorde det även väldigt lätt för oss att implementera tvåspelarläge.

Abstract Factory
 Vi har ett interface kallat WorldObjectSpawner som vi skickar till World. Varje gång en ny Zone i World skapas kommer alla WorldObjectSpawner som vi har lagt in i World att köras. WorldObjectSpawner spawnar då nya objekt.
 Just nu har vi bara en WorldObjectSpawner som spawnar asteroider. WorldObjectSpawner spawnar WorldObjects.

States/något annat?

6.4. Användning av objektorientering
Vi har en abstrakt klass WorldObject som alla objekt som finns i World ärver av. Detta gör att vi kan försäkra att de funktioner som behövs för att hantera objekten i World finns i alla objekt och fungerar på samma sätt.
Om vi vill att en funktion ska göra något annat än vad som specifieras i WorldObject så använder vi polymorfism för att åstadkomma detta. Update har till exempel en mycket enkel implementation i WorldObject, men t ex så lägger vi till en positionscheck i MoveableObject och en kollisionscheck i CollideableObject. Vi slipper implementera samma sak i flera klasser då MoveableObjects Update återanvänder Update i WorldObject och CollideableObject återanvänder Update i MoveableObject.

Vi hade istället kunnat ha låtit World bara ta Object och sedan implementera skilda klasser som vi lägger in i World. Vi hade då tvingats ha samma kod i alla klasser och dessutom hade det varit svårare att garantera att World kan kommunicera med objekten.



6.5. Motiverade designbeslut med alternativ
World
 Världen skapar vi som ett World-objekt. Detta består av flera zoner som är Zone-objekt. Istället för att ha en specifik funktion som skapar zonerna så görs detta dynamiskt i GetZone så fort vi försöker komma åt en zon. World tar även bort zoner när vi anser att de är tillräckligt långt bort.
 På detta sätt kan vi lätt göra våran värld större och mindre så att den för spelaren upplevs som oändlig. Zonuppdelningen möjliggör även för oss att enklare plocka ut objekt från vissa delar av världen utan att behöva söka igenom alla objekt och jämföra deras positioner.

 Först lät vi World uppdatera objekten, men för att hålla oss till det objektorienterade tankesättet så lät vi istället varje objekt uppdatera sig självt. Så allt World gör är att den anropar varje objekts update-funktion.
 På detta sätt slapp vi en massa falluppdelning(är objektet Moveable, Collideabel..?) och det är enklare att ha denna kod i objektet självt. Vi slipper ändra i World när vi lägger in ett nytt objekt.

 Vi mappar varje zon till dess koordinat i en HashMap. Denna datastruktur låter oss komma åt alla zoner väldigt snabbt.

Zone
 Denna klass lagrar egentligen bara WorldObjects, men varje zon innehåller endast objekt inom ett visst område. Vi har gjort denna klass trådsäker för att flera Viewers och Controllers ska kunna komma åt objekten samtidigt som de uppdateras.
 Vi hade egentligen bara kunnat ha någonting som lagrade WorldObjekts trådsäkert (t ex ConcurrentLinkedQueue som är den underliggande strukturen), men har istället valt att göra en egen klass för tydlighetens skull och för att kunna he en del annan funktionalitet i klassen.

7. Användarmanual
Den här delen skriver ni inför slutinlämningen
När ni har implementerat ett program krävs det också en manual som förklarar hur programmet fungerar. Ni ska beskriva programmet tillräckligt mycket för att en labbhandledare själv ska kunna starta det, testa det och förstå hur det fungerar.   Inkludera skärmdumpar som visar hur programmet ser ut.

8. Betygsambitioner
Den här delen skriver ni inför slutinlämningen
Ange här vilket betyg ni har siktat på i ert projekt.  Se sedan till att ni har följt de mätbara kraven för detta betyg och att detta finns dokumenterat i projektbeskrivningen ovan.

9. Utvärdering och erfarenheter
Den här delen skriver ni inför slutinlämningen
Detta avsnitt är en väldigt viktig del av projektspecifikationen. Här ska ni tänka tillbaka och utvärdera projektet (något som alltid ska göra efter ett projekt). Som en hjälp på vägen kan ni utgå från följande frågeställningar:
Vad gick bra? Mindre bra?
Lade ni ned för mycket/lite tid?
Var arbetsfördelningen jämn? Om inte: Vad hade ni kunnat göra för att förbättra den?
Har ni haft någon nytta av specifikationen? Vad har varit mest användbart med den? Minst?
Har arbetet fungerat som ni tänkt er? Har ni följt "arbetsmetodiken"? Något som skiljer sig? Till det bättre? Till det sämre?
Vad har varit mest problematiskt, om man utesluter den programmeringstekniska delen? Alltså saker runt omkring, som att hitta ledig tid eller plats att vara på.
Vad har ni lärt er så här långt som kan vara bra att ta med till era egna kommande kurser/projekt?
Vilka tips skulle ni vilja ge till studenter i nästa års kurs?
Har ni saknat något i kursen som hade underlättat projektet?
